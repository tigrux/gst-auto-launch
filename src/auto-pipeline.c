/* auto-pipeline.c generated by valac, the Vala compiler
 * generated from auto-pipeline.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>


#define TYPE_COMMAND (command_get_type ())

#define TYPE_AUTO_PIPELINE (auto_pipeline_get_type ())
#define AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AUTO_PIPELINE, AutoPipeline))
#define AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AUTO_PIPELINE, AutoPipelineClass))
#define IS_AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AUTO_PIPELINE))
#define IS_AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AUTO_PIPELINE))
#define AUTO_PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AUTO_PIPELINE, AutoPipelineClass))

typedef struct _AutoPipeline AutoPipeline;
typedef struct _AutoPipelineClass AutoPipelineClass;

#define TYPE_OBJECT_LIST (object_list_get_type ())
#define OBJECT_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OBJECT_LIST, ObjectList))
#define OBJECT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OBJECT_LIST, ObjectListClass))
#define IS_OBJECT_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OBJECT_LIST))
#define IS_OBJECT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OBJECT_LIST))
#define OBJECT_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OBJECT_LIST, ObjectListClass))

typedef struct _ObjectList ObjectList;
typedef struct _ObjectListClass ObjectListClass;
typedef struct _Command Command;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _AutoPipelinePrivate AutoPipelinePrivate;

#define OBJECT_LIST_TYPE_ITERATOR (object_list_iterator_get_type ())
#define OBJECT_LIST_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECT_LIST_TYPE_ITERATOR, ObjectListIterator))
#define OBJECT_LIST_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECT_LIST_TYPE_ITERATOR, ObjectListIteratorClass))
#define OBJECT_LIST_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECT_LIST_TYPE_ITERATOR))
#define OBJECT_LIST_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECT_LIST_TYPE_ITERATOR))
#define OBJECT_LIST_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECT_LIST_TYPE_ITERATOR, ObjectListIteratorClass))

typedef struct _ObjectListIterator ObjectListIterator;
typedef struct _ObjectListIteratorClass ObjectListIteratorClass;
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _object_list_iterator_unref0(var) ((var == NULL) ? NULL : (var = (object_list_iterator_unref (var), NULL)))
typedef struct _Block2Data Block2Data;
typedef struct _Block1Data Block1Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef void (*command_func) (AutoPipeline* ctx, ObjectList* param, void* user_data);
struct _Command {
	char* name;
	char* description;
	command_func function;
	gpointer function_target;
	GDestroyNotify function_target_destroy_notify;
};

struct _AutoPipeline {
	GObject parent_instance;
	AutoPipelinePrivate * priv;
};

struct _AutoPipelineClass {
	GObjectClass parent_class;
};

struct _AutoPipelinePrivate {
	GstBin* _pipeline;
	GMainLoop* _loop;
	ObjectList* _parameters;
	ObjectListIterator* iterator;
};

struct _Block2Data {
	int _ref_count_;
	Block1Data * _data1_;
	Command command;
};

struct _Block1Data {
	int _ref_count_;
	AutoPipeline * self;
	ObjectList* param;
};


static gpointer auto_pipeline_parent_class = NULL;

GType command_get_type (void);
GType auto_pipeline_get_type (void);
GType object_list_get_type (void);
Command* command_dup (const Command* self);
void command_free (Command* self);
void command_copy (const Command* self, Command* dest);
void command_destroy (Command* self);
gpointer object_list_iterator_ref (gpointer instance);
void object_list_iterator_unref (gpointer instance);
GParamSpec* object_list_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void object_list_value_set_iterator (GValue* value, gpointer v_object);
gpointer object_list_value_get_iterator (const GValue* value);
GType object_list_iterator_get_type (void);
#define AUTO_PIPELINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_AUTO_PIPELINE, AutoPipelinePrivate))
enum  {
	AUTO_PIPELINE_DUMMY_PROPERTY,
	AUTO_PIPELINE_STATE,
	AUTO_PIPELINE_PIPELINE,
	AUTO_PIPELINE_LOOP,
	AUTO_PIPELINE_PARAMETERS
};
static void auto_pipeline_on_bus_message (AutoPipeline* self, GstMessage* message);
static void _auto_pipeline_on_bus_message_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);
void auto_pipeline_parse (AutoPipeline* self, const char* description, GError** error);
gboolean object_list_iterator_next (ObjectListIterator* self);
gconstpointer object_list_iterator_get (ObjectListIterator* self);
const char* object_list_get_name (ObjectList* self);
void command_play (AutoPipeline* ctx, ObjectList* param);
static void _command_play_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_pause (AutoPipeline* ctx, ObjectList* param);
static void _command_pause_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_ready (AutoPipeline* ctx, ObjectList* param);
static void _command_ready_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_null (AutoPipeline* ctx, ObjectList* param);
static void _command_null_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_wait (AutoPipeline* ctx, ObjectList* param);
static void _command_wait_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_eos (AutoPipeline* ctx, ObjectList* param);
static void _command_eos_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_quit (AutoPipeline* ctx, ObjectList* param);
static void _command_quit_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
static gboolean _lambda1_ (Block2Data* _data2_);
static gboolean __lambda1__gsource_func (gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static gboolean auto_pipeline_do_exec_parameters (AutoPipeline* self);
ObjectList* object_list_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func);
ObjectList* object_list_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func);
void object_list_append (ObjectList* self, gconstpointer s);
void object_list_set_name (ObjectList* self, const char* value);
void auto_pipeline_parse_parameters (AutoPipeline* self, char** args, int args_length1);
ObjectList* auto_pipeline_get_parameters (AutoPipeline* self);
ObjectListIterator* object_list_iterator (ObjectList* self);
void auto_pipeline_continue_exec (AutoPipeline* self);
void auto_pipeline_exec_parameters (AutoPipeline* self);
static gboolean _auto_pipeline_do_exec_parameters_gsource_func (gpointer self);
void auto_pipeline_continue_exec_in_seconds (AutoPipeline* self, guint n_seconds);
void auto_pipeline_set_state (AutoPipeline* self, GstState value);
AutoPipeline* auto_pipeline_new (void);
AutoPipeline* auto_pipeline_construct (GType object_type);
GstBin* auto_pipeline_get_pipeline (AutoPipeline* self);
void auto_pipeline_set_pipeline (AutoPipeline* self, GstBin* value);
GMainLoop* auto_pipeline_get_loop (AutoPipeline* self);
void auto_pipeline_set_loop (AutoPipeline* self, GMainLoop* value);
void auto_pipeline_set_parameters (AutoPipeline* self, ObjectList* value);
static GObject * auto_pipeline_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void auto_pipeline_finalize (GObject* obj);
static void auto_pipeline_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void auto_pipeline_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static int _vala_strcmp0 (const char * str1, const char * str2);

extern const Command COMMANDS[];


void command_copy (const Command* self, Command* dest) {
	dest->name = g_strdup (self->name);
	dest->description = g_strdup (self->description);
	dest->function = self->function;
}


void command_destroy (Command* self) {
	_g_free0 (self->name);
	_g_free0 (self->description);
	((*self).function_target_destroy_notify == NULL) ? NULL : (*self).function_target_destroy_notify ((*self).function_target);
	self->function = NULL;
	(*self).function_target = NULL;
	(*self).function_target_destroy_notify = NULL;
}


Command* command_dup (const Command* self) {
	Command* dup;
	dup = g_new0 (Command, 1);
	command_copy (self, dup);
	return dup;
}


void command_free (Command* self) {
	command_destroy (self);
	g_free (self);
}


GType command_get_type (void) {
	static GType command_type_id = 0;
	if (command_type_id == 0) {
		command_type_id = g_boxed_type_register_static ("Command", (GBoxedCopyFunc) command_dup, (GBoxedFreeFunc) command_free);
	}
	return command_type_id;
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static void _auto_pipeline_on_bus_message_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
	auto_pipeline_on_bus_message (self, message);
}


void auto_pipeline_parse (AutoPipeline* self, const char* description, GError** error) {
	GError * _inner_error_;
	GstElement* _tmp0_;
	GstBin* _tmp2_;
	GstElement* _tmp1_;
	GstBus* bus;
	g_return_if_fail (self != NULL);
	g_return_if_fail (description != NULL);
	_inner_error_ = NULL;
	_tmp0_ = gst_parse_launch (description, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	self->priv->_pipeline = (_tmp2_ = (_tmp1_ = _tmp0_, GST_IS_BIN (_tmp1_) ? ((GstBin*) _tmp1_) : NULL), _gst_object_unref0 (self->priv->_pipeline), _tmp2_);
	bus = _gst_object_ref0 (((GstElement*) self->priv->_pipeline)->bus);
	gst_bus_add_signal_watch (bus);
	g_signal_connect_object (bus, "message", (GCallback) _auto_pipeline_on_bus_message_gst_bus_message, self, 0);
	_gst_object_unref0 (bus);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _command_play_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_play (ctx, param);
}


static void _command_pause_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_pause (ctx, param);
}


static void _command_ready_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_ready (ctx, param);
}


static void _command_null_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_null (ctx, param);
}


static void _command_wait_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_wait (ctx, param);
}


static void _command_eos_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_eos (ctx, param);
}


static void _command_quit_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_quit (ctx, param);
}


static gboolean _lambda1_ (Block2Data* _data2_) {
	Block1Data* _data1_;
	AutoPipeline * self;
	gboolean result;
	_data1_ = _data2_->_data1_;
	self = _data1_->self;
	_data2_->command.function (self, _data1_->param, _data2_->command.function_target);
	result = FALSE;
	return result;
}


static gboolean __lambda1__gsource_func (gpointer self) {
	return _lambda1_ (self);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	++_data2_->_ref_count_;
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if ((--_data2_->_ref_count_) == 0) {
		block1_data_unref (_data2_->_data1_);
		command_destroy (&_data2_->command);
		g_slice_free (Block2Data, _data2_);
	}
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	++_data1_->_ref_count_;
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if ((--_data1_->_ref_count_) == 0) {
		_g_object_unref0 (_data1_->self);
		_g_object_unref0 (_data1_->param);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean auto_pipeline_do_exec_parameters (AutoPipeline* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (object_list_iterator_next (self->priv->iterator)) {
		Block1Data* _data1_;
		const char* param_name;
		guint i;
		_data1_ = g_slice_new0 (Block1Data);
		_data1_->_ref_count_ = 1;
		_data1_->self = g_object_ref (self);
		_data1_->param = _g_object_ref0 ((ObjectList*) object_list_iterator_get (self->priv->iterator));
		param_name = object_list_get_name (_data1_->param);
		i = (guint) 0;
		while (TRUE) {
			Block2Data* _data2_;
			Command _tmp0_ = {0};
			_data2_ = g_slice_new0 (Block2Data);
			_data2_->_ref_count_ = 1;
			_data2_->_data1_ = block1_data_ref (_data1_);
			_data2_->command = (command_copy (&COMMANDS[i], &_tmp0_), _tmp0_);
			if (_data2_->command.name == NULL) {
				g_print ("There is no command named '%s'\n", param_name);
				block2_data_unref (_data2_);
				break;
			}
			if (_vala_strcmp0 (_data2_->command.name, param_name) == 0) {
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __lambda1__gsource_func, block2_data_ref (_data2_), block2_data_unref);
				block2_data_unref (_data2_);
				break;
			}
			i++;
			block2_data_unref (_data2_);
		}
		block1_data_unref (_data1_);
	}
	result = FALSE;
	return result;
}


void auto_pipeline_parse_parameters (AutoPipeline* self, char** args, int args_length1) {
	ObjectList* _tmp0_;
	ObjectList* current_parameter;
	g_return_if_fail (self != NULL);
	self->priv->_parameters = (_tmp0_ = object_list_new (TYPE_OBJECT_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref), _g_object_unref0 (self->priv->_parameters), _tmp0_);
	current_parameter = NULL;
	{
		char** arg_collection;
		int arg_collection_length1;
		int arg_it;
		arg_collection = args;
		arg_collection_length1 = args_length1;
		for (arg_it = 0; arg_it < args_length1; arg_it = arg_it + 1) {
			char* arg;
			arg = g_strdup (arg_collection[arg_it]);
			{
				if (g_str_has_prefix (arg, "-")) {
					char* param_name;
					ObjectList* _tmp1_;
					if (current_parameter != NULL) {
						object_list_append (self->priv->_parameters, current_parameter);
					}
					param_name = g_strdup (g_utf8_next_char (arg));
					current_parameter = (_tmp1_ = object_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free), _g_object_unref0 (current_parameter), _tmp1_);
					object_list_set_name (current_parameter, param_name);
					_g_free0 (param_name);
				} else {
					if (current_parameter != NULL) {
						object_list_append (current_parameter, arg);
					} else {
						g_warning ("auto-pipeline.vala:91: Got argument '%s' without preceding parameter\n", arg);
					}
				}
				_g_free0 (arg);
			}
		}
	}
	if (current_parameter != NULL) {
		object_list_append (self->priv->_parameters, current_parameter);
	}
	_g_object_unref0 (current_parameter);
}


void auto_pipeline_exec_parameters (AutoPipeline* self) {
	ObjectListIterator* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->iterator = (_tmp0_ = object_list_iterator (self->priv->_parameters), _object_list_iterator_unref0 (self->priv->iterator), _tmp0_);
	auto_pipeline_continue_exec (self);
}


static gboolean _auto_pipeline_do_exec_parameters_gsource_func (gpointer self) {
	return auto_pipeline_do_exec_parameters (self);
}


void auto_pipeline_continue_exec (AutoPipeline* self) {
	g_return_if_fail (self != NULL);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _auto_pipeline_do_exec_parameters_gsource_func, g_object_ref (self), g_object_unref);
}


void auto_pipeline_continue_exec_in_seconds (AutoPipeline* self, guint n_seconds) {
	g_return_if_fail (self != NULL);
	g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, n_seconds, _auto_pipeline_do_exec_parameters_gsource_func, g_object_ref (self), g_object_unref);
}


static void auto_pipeline_on_bus_message (AutoPipeline* self, GstMessage* message) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	switch (message->type) {
		case GST_MESSAGE_ERROR:
		{
			{
				GError* e;
				char* s;
				char* _tmp3_;
				char* _tmp2_ = NULL;
				GError* _tmp1_;
				GError* _tmp0_ = NULL;
				e = NULL;
				s = NULL;
				(gst_message_parse_error (message, &_tmp0_, &_tmp2_), e = (_tmp1_ = _tmp0_, _g_error_free0 (e), _tmp1_));
				s = (_tmp3_ = _tmp2_, _g_free0 (s), _tmp3_);
				g_critical ("auto-pipeline.vala:123: Bus error: %s %s\n", e->message, s);
				_g_error_free0 (e);
				_g_free0 (s);
				break;
			}
		}
		case GST_MESSAGE_EOS:
		{
			{
				g_print ("Got eos\n");
				auto_pipeline_set_state (self, GST_STATE_NULL);
				g_main_loop_quit (self->priv->_loop);
				break;
			}
		}
		default:
		{
			break;
		}
	}
}


AutoPipeline* auto_pipeline_construct (GType object_type) {
	AutoPipeline * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


AutoPipeline* auto_pipeline_new (void) {
	return auto_pipeline_construct (TYPE_AUTO_PIPELINE);
}


void auto_pipeline_set_state (AutoPipeline* self, GstState value) {
	g_return_if_fail (self != NULL);
	gst_element_set_state ((GstElement*) self->priv->_pipeline, value);
	g_object_notify ((GObject *) self, "state");
}


GstBin* auto_pipeline_get_pipeline (AutoPipeline* self) {
	GstBin* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_pipeline;
	return result;
}


void auto_pipeline_set_pipeline (AutoPipeline* self, GstBin* value) {
	GstBin* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_pipeline = (_tmp0_ = _gst_object_ref0 (value), _gst_object_unref0 (self->priv->_pipeline), _tmp0_);
	g_object_notify ((GObject *) self, "pipeline");
}


GMainLoop* auto_pipeline_get_loop (AutoPipeline* self) {
	GMainLoop* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_loop;
	return result;
}


static gpointer _g_main_loop_ref0 (gpointer self) {
	return self ? g_main_loop_ref (self) : NULL;
}


void auto_pipeline_set_loop (AutoPipeline* self, GMainLoop* value) {
	GMainLoop* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_loop = (_tmp0_ = _g_main_loop_ref0 (value), _g_main_loop_unref0 (self->priv->_loop), _tmp0_);
	g_object_notify ((GObject *) self, "loop");
}


ObjectList* auto_pipeline_get_parameters (AutoPipeline* self) {
	ObjectList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_parameters;
	return result;
}


void auto_pipeline_set_parameters (AutoPipeline* self, ObjectList* value) {
	ObjectList* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_parameters = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_parameters), _tmp0_);
	g_object_notify ((GObject *) self, "parameters");
}


static GObject * auto_pipeline_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	AutoPipeline * self;
	parent_class = G_OBJECT_CLASS (auto_pipeline_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = AUTO_PIPELINE (obj);
	{
		GMainLoop* _tmp0_;
		self->priv->_loop = (_tmp0_ = g_main_loop_new (NULL, FALSE), _g_main_loop_unref0 (self->priv->_loop), _tmp0_);
	}
	return obj;
}


static void auto_pipeline_class_init (AutoPipelineClass * klass) {
	auto_pipeline_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AutoPipelinePrivate));
	G_OBJECT_CLASS (klass)->get_property = auto_pipeline_get_property;
	G_OBJECT_CLASS (klass)->set_property = auto_pipeline_set_property;
	G_OBJECT_CLASS (klass)->constructor = auto_pipeline_constructor;
	G_OBJECT_CLASS (klass)->finalize = auto_pipeline_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUTO_PIPELINE_STATE, g_param_spec_enum ("state", "state", "state", GST_TYPE_STATE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUTO_PIPELINE_PIPELINE, g_param_spec_object ("pipeline", "pipeline", "pipeline", GST_TYPE_BIN, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUTO_PIPELINE_LOOP, g_param_spec_pointer ("loop", "loop", "loop", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUTO_PIPELINE_PARAMETERS, g_param_spec_object ("parameters", "parameters", "parameters", TYPE_OBJECT_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void auto_pipeline_instance_init (AutoPipeline * self) {
	self->priv = AUTO_PIPELINE_GET_PRIVATE (self);
}


static void auto_pipeline_finalize (GObject* obj) {
	AutoPipeline * self;
	self = AUTO_PIPELINE (obj);
	_gst_object_unref0 (self->priv->_pipeline);
	_g_main_loop_unref0 (self->priv->_loop);
	_g_object_unref0 (self->priv->_parameters);
	_object_list_iterator_unref0 (self->priv->iterator);
	G_OBJECT_CLASS (auto_pipeline_parent_class)->finalize (obj);
}


GType auto_pipeline_get_type (void) {
	static GType auto_pipeline_type_id = 0;
	if (auto_pipeline_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (AutoPipelineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) auto_pipeline_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AutoPipeline), 0, (GInstanceInitFunc) auto_pipeline_instance_init, NULL };
		auto_pipeline_type_id = g_type_register_static (G_TYPE_OBJECT, "AutoPipeline", &g_define_type_info, 0);
	}
	return auto_pipeline_type_id;
}


static void auto_pipeline_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	AutoPipeline * self;
	self = AUTO_PIPELINE (object);
	switch (property_id) {
		case AUTO_PIPELINE_PIPELINE:
		g_value_set_object (value, auto_pipeline_get_pipeline (self));
		break;
		case AUTO_PIPELINE_LOOP:
		g_value_set_pointer (value, auto_pipeline_get_loop (self));
		break;
		case AUTO_PIPELINE_PARAMETERS:
		g_value_set_object (value, auto_pipeline_get_parameters (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void auto_pipeline_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	AutoPipeline * self;
	self = AUTO_PIPELINE (object);
	switch (property_id) {
		case AUTO_PIPELINE_STATE:
		auto_pipeline_set_state (self, g_value_get_enum (value));
		break;
		case AUTO_PIPELINE_PIPELINE:
		auto_pipeline_set_pipeline (self, g_value_get_object (value));
		break;
		case AUTO_PIPELINE_LOOP:
		auto_pipeline_set_loop (self, g_value_get_pointer (value));
		break;
		case AUTO_PIPELINE_PARAMETERS:
		auto_pipeline_set_parameters (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




