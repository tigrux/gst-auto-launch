/* commands.c generated by valac, the Vala compiler
 * generated from commands.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>


#define TYPE_AUTO_PIPELINE (auto_pipeline_get_type ())
#define AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AUTO_PIPELINE, AutoPipeline))
#define AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AUTO_PIPELINE, AutoPipelineClass))
#define IS_AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AUTO_PIPELINE))
#define IS_AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AUTO_PIPELINE))
#define AUTO_PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AUTO_PIPELINE, AutoPipelineClass))

typedef struct _AutoPipeline AutoPipeline;
typedef struct _AutoPipelineClass AutoPipelineClass;

#define TYPE_COMMAND (command_get_type ())
typedef struct _Command Command;
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _gst_iterator_free0(var) ((var == NULL) ? NULL : (var = (gst_iterator_free (var), NULL)))

typedef void (*CommandFunc) (AutoPipeline* ctx, void* user_data);
struct _Command {
	char* name;
	char* description;
	CommandFunc function;
	gpointer function_target;
	GDestroyNotify function_target_destroy_notify;
};



GType auto_pipeline_get_type (void);
void command_play (AutoPipeline* ctx);
static void _command_play_command_func (AutoPipeline* ctx, gpointer self);
void command_pause (AutoPipeline* ctx);
static void _command_pause_command_func (AutoPipeline* ctx, gpointer self);
void command_ready (AutoPipeline* ctx);
static void _command_ready_command_func (AutoPipeline* ctx, gpointer self);
void command_null (AutoPipeline* ctx);
static void _command_null_command_func (AutoPipeline* ctx, gpointer self);
void command_eos (AutoPipeline* ctx);
static void _command_eos_command_func (AutoPipeline* ctx, gpointer self);
void command_quit (AutoPipeline* ctx);
static void _command_quit_command_func (AutoPipeline* ctx, gpointer self);
GType command_get_type (void);
Command* command_dup (const Command* self);
void command_free (Command* self);
void command_copy (const Command* self, Command* dest);
void command_destroy (Command* self);
void auto_pipeline_set_state (AutoPipeline* self, GstState value);
GMainLoop* auto_pipeline_get_loop (AutoPipeline* self);
GstBin* auto_pipeline_get_pipeline (AutoPipeline* self);
static void _lambda1_ (void* data);
static void __lambda1__gfunc (void* data, gpointer self);
void scanner_register_symbols (GScanner* scanner, guint scope);

static const Command COMMANDS[] = {{"play", "Change pipeline state to PLAYING", _command_play_command_func}, {"pause", "Change pipeline state to PAUSED", _command_pause_command_func}, {"ready", "Change pipeline state to READY", _command_ready_command_func}, {"stop", "Change pipeline state to READY", _command_ready_command_func}, {"null", "Change pipeline state to NULL", _command_null_command_func}, {"eos", "Send eos to the source elements", _command_eos_command_func}, {"quit", "Quit the event loop", _command_quit_command_func}, {NULL}};


static void _command_play_command_func (AutoPipeline* ctx, gpointer self) {
	command_play (ctx);
}


static void _command_pause_command_func (AutoPipeline* ctx, gpointer self) {
	command_pause (ctx);
}


static void _command_ready_command_func (AutoPipeline* ctx, gpointer self) {
	command_ready (ctx);
}


static void _command_null_command_func (AutoPipeline* ctx, gpointer self) {
	command_null (ctx);
}


static void _command_eos_command_func (AutoPipeline* ctx, gpointer self) {
	command_eos (ctx);
}


static void _command_quit_command_func (AutoPipeline* ctx, gpointer self) {
	command_quit (ctx);
}


void command_play (AutoPipeline* ctx) {
	g_return_if_fail (ctx != NULL);
	g_print ("Changing to PLAYING\n");
	auto_pipeline_set_state (ctx, GST_STATE_PLAYING);
}


void command_pause (AutoPipeline* ctx) {
	g_return_if_fail (ctx != NULL);
	g_print ("Changing to PAUSED\n");
	auto_pipeline_set_state (ctx, GST_STATE_PAUSED);
}


void command_ready (AutoPipeline* ctx) {
	g_return_if_fail (ctx != NULL);
	g_print ("Changing to READY\n");
	auto_pipeline_set_state (ctx, GST_STATE_READY);
}


void command_null (AutoPipeline* ctx) {
	g_return_if_fail (ctx != NULL);
	g_print ("Changing to NULL\n");
	auto_pipeline_set_state (ctx, GST_STATE_NULL);
}


void command_quit (AutoPipeline* ctx) {
	g_return_if_fail (ctx != NULL);
	g_print ("Quitting\n");
	g_main_loop_quit (auto_pipeline_get_loop (ctx));
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static void _lambda1_ (void* data) {
	void* _tmp0_;
	GstElement* elem;
	elem = _gst_object_ref0 ((_tmp0_ = data, GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL));
	if (string_contains (gst_object_get_name ((GstObject*) elem), "src")) {
		g_print ("Sending eos to %s\n", gst_object_get_name ((GstObject*) elem));
		gst_element_send_event (elem, gst_event_new_eos ());
	}
	_gst_object_unref0 (elem);
}


static void __lambda1__gfunc (void* data, gpointer self) {
	_lambda1_ (data);
}


void command_eos (AutoPipeline* ctx) {
	GstIterator* _tmp0_;
	g_return_if_fail (ctx != NULL);
	g_print ("Trying to send eos to the sources\n");
	gst_iterator_foreach (_tmp0_ = gst_bin_iterate_elements (auto_pipeline_get_pipeline (ctx)), __lambda1__gfunc, NULL);
	_gst_iterator_free0 (_tmp0_);
}


void scanner_register_symbols (GScanner* scanner, guint scope) {
	Command* command;
	g_return_if_fail (scanner != NULL);
	command = &COMMANDS[0];
	while (TRUE) {
		if (!((*command).name != NULL)) {
			break;
		}
		g_scanner_scope_add_symbol (scanner, scope, (*command).name, command);
		command++;
	}
}




