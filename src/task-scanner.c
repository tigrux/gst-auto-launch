/* task-scanner.c generated by valac, the Vala compiler
 * generated from task-scanner.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

typedef GScanner TaskScanner;

#define TYPE_TASK (task_get_type ())
#define TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TASK, Task))
#define TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TASK, TaskClass))
#define IS_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TASK))
#define IS_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TASK))
#define TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TASK, TaskClass))

typedef struct _Task Task;
typedef struct _TaskClass TaskClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_COMMAND (command_get_type ())

#define TYPE_AUTO_PIPELINE (auto_pipeline_get_type ())
#define AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AUTO_PIPELINE, AutoPipeline))
#define AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AUTO_PIPELINE, AutoPipelineClass))
#define IS_AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AUTO_PIPELINE))
#define IS_AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AUTO_PIPELINE))
#define AUTO_PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AUTO_PIPELINE, AutoPipelineClass))

typedef struct _AutoPipeline AutoPipeline;
typedef struct _AutoPipelineClass AutoPipelineClass;
typedef struct _Command Command;
#define _command_free0(var) ((var == NULL) ? NULL : (var = (command_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))

typedef void (*CommandFunc) (AutoPipeline* ctx, Task* task, void* user_data);
struct _Command {
	char* name;
	char* description;
	CommandFunc function;
	gpointer function_target;
	GDestroyNotify function_target_destroy_notify;
};



void scanner_register_symbols (GScanner* scanner, guint scope);
TaskScanner* task_scanner_new (void);
TaskScanner* task_scanner_new (void);
GType task_get_type (void);
GType command_get_type (void);
GType auto_pipeline_get_type (void);
Command* command_dup (const Command* self);
void command_free (Command* self);
void command_copy (const Command* self, Command* dest);
void command_destroy (Command* self);
Task* task_new (double seconds, Command* command);
Task* task_construct (GType object_type, double seconds, Command* command);
GValueArray* task_get_arguments (Task* self);
static void _g_list_free_g_object_unref (GList* self);
GList* task_scanner_get_tasks_from_args (TaskScanner* self, char** args, int args_length1);
static int _vala_strcmp0 (const char * str1, const char * str2);



TaskScanner* task_scanner_new (void) {
	TaskScanner* self;
	self = (TaskScanner*) g_scanner_new (NULL);
	(*((GScanner*) self)->config).scan_identifier_1char = FALSE;
	scanner_register_symbols ((GScanner*) self, (guint) 0);
	return self;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, -1);
	return result;
}


static gpointer _command_dup0 (gpointer self) {
	return self ? command_dup (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


GList* task_scanner_get_tasks_from_args (TaskScanner* self, char** args, int args_length1) {
	GList* result = NULL;
	double last_time_seconds;
	GList* tasks;
	g_return_val_if_fail (self != NULL, NULL);
	last_time_seconds = (double) 0;
	tasks = NULL;
	{
		char** arg_collection;
		int arg_collection_length1;
		int arg_it;
		arg_collection = args;
		arg_collection_length1 = args_length1;
		for (arg_it = 0; arg_it < args_length1; arg_it = arg_it + 1) {
			char* arg;
			arg = g_strdup (arg_collection[arg_it]);
			{
				gint relative;
				GTokenType tok_type;
				gboolean _tmp0_ = FALSE;
				double seconds = 0.0;
				Command* command;
				Task* task;
				if (g_str_has_prefix (arg, "--")) {
					_g_free0 (arg);
					continue;
				}
				g_scanner_input_text ((GScanner*) self, arg, (guint) string_get_length (arg));
				relative = 0;
				tok_type = g_scanner_peek_next_token ((GScanner*) self);
				if (tok_type == G_TOKEN_EOF) {
					_g_free0 (arg);
					break;
				}
				if (tok_type == '+') {
					relative = 1;
				} else {
					if (tok_type == '-') {
						relative = -1;
					}
				}
				if (relative != 0) {
					g_scanner_get_next_token ((GScanner*) self);
				}
				tok_type = g_scanner_peek_next_token ((GScanner*) self);
				if (tok_type != G_TOKEN_FLOAT) {
					_tmp0_ = tok_type != G_TOKEN_INT;
				} else {
					_tmp0_ = FALSE;
				}
				if (_tmp0_) {
					_g_free0 (arg);
					continue;
				}
				g_scanner_get_next_token ((GScanner*) self);
				if (tok_type == G_TOKEN_FLOAT) {
					seconds = ((GScanner*) self)->value.v_float;
				} else {
					seconds = (double) ((GScanner*) self)->value.v_int;
				}
				if (relative != 0) {
					seconds = last_time_seconds + (relative * seconds);
				}
				if (g_scanner_peek_next_token ((GScanner*) self) != ':') {
					_g_free0 (arg);
					continue;
				}
				g_scanner_get_next_token ((GScanner*) self);
				if (g_scanner_peek_next_token ((GScanner*) self) != G_TOKEN_SYMBOL) {
					_g_free0 (arg);
					continue;
				}
				g_scanner_get_next_token ((GScanner*) self);
				command = _command_dup0 ((Command*) ((GScanner*) self)->value.v_symbol);
				task = task_new (seconds, command);
				while (TRUE) {
					if (!(g_scanner_peek_next_token ((GScanner*) self) == ':')) {
						break;
					}
					g_scanner_get_next_token ((GScanner*) self);
					tok_type = g_scanner_get_next_token ((GScanner*) self);
					switch (tok_type) {
						case G_TOKEN_INT:
						{
							GValue _tmp2_;
							GValue _tmp1_ = {0};
							g_value_array_append (task_get_arguments (task), (_tmp2_ = (g_value_init (&_tmp1_, G_TYPE_ULONG), g_value_set_ulong (&_tmp1_, ((GScanner*) self)->value.v_int), _tmp1_), &_tmp2_));
							break;
						}
						case G_TOKEN_FLOAT:
						{
							GValue _tmp4_;
							GValue _tmp3_ = {0};
							g_value_array_append (task_get_arguments (task), (_tmp4_ = (g_value_init (&_tmp3_, G_TYPE_DOUBLE), g_value_set_double (&_tmp3_, ((GScanner*) self)->value.v_float), _tmp3_), &_tmp4_));
							break;
						}
						case G_TOKEN_IDENTIFIER:
						case G_TOKEN_STRING:
						{
							if (_vala_strcmp0 (((GScanner*) self)->value.v_string, "true") == 0) {
								GValue _tmp6_;
								GValue _tmp5_ = {0};
								g_value_array_append (task_get_arguments (task), (_tmp6_ = (g_value_init (&_tmp5_, G_TYPE_BOOLEAN), g_value_set_boolean (&_tmp5_, TRUE), _tmp5_), &_tmp6_));
							} else {
								if (_vala_strcmp0 (((GScanner*) self)->value.v_string, "false") == 0) {
									GValue _tmp8_;
									GValue _tmp7_ = {0};
									g_value_array_append (task_get_arguments (task), (_tmp8_ = (g_value_init (&_tmp7_, G_TYPE_BOOLEAN), g_value_set_boolean (&_tmp7_, FALSE), _tmp7_), &_tmp8_));
								} else {
									GValue _tmp10_;
									GValue _tmp9_ = {0};
									g_value_array_append (task_get_arguments (task), (_tmp10_ = (g_value_init (&_tmp9_, G_TYPE_STRING), g_value_set_string (&_tmp9_, ((GScanner*) self)->value.v_string), _tmp9_), &_tmp10_));
								}
							}
							break;
						}
						default:
						{
							g_print ("** TokType = %c\n", (gint) tok_type);
							break;
						}
					}
				}
				tasks = g_list_append (tasks, _g_object_ref0 (task));
				last_time_seconds = seconds;
				_g_free0 (arg);
				_command_free0 (command);
				_g_object_unref0 (task);
			}
		}
	}
	result = tasks;
	return result;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




