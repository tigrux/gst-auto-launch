/* task-scanner.c generated by valac, the Vala compiler
 * generated from task-scanner.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

typedef GScanner TaskScanner;

#define TYPE_TASK (task_get_type ())
#define TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TASK, Task))
#define TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TASK, TaskClass))
#define IS_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TASK))
#define IS_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TASK))
#define TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TASK, TaskClass))

typedef struct _Task Task;
typedef struct _TaskClass TaskClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_COMMAND (command_get_type ())

#define TYPE_AUTO_PIPELINE (auto_pipeline_get_type ())
#define AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AUTO_PIPELINE, AutoPipeline))
#define AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AUTO_PIPELINE, AutoPipelineClass))
#define IS_AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AUTO_PIPELINE))
#define IS_AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AUTO_PIPELINE))
#define AUTO_PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AUTO_PIPELINE, AutoPipelineClass))

typedef struct _AutoPipeline AutoPipeline;
typedef struct _AutoPipelineClass AutoPipelineClass;
typedef struct _Command Command;
#define _command_free0(var) ((var == NULL) ? NULL : (var = (command_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))

typedef void (*CommandFunc) (AutoPipeline* ctx, void* user_data);
struct _Command {
	char* name;
	char* description;
	CommandFunc function;
	gpointer function_target;
	GDestroyNotify function_target_destroy_notify;
};



void scanner_register_symbols (GScanner* scanner, guint scope);
TaskScanner* task_scanner_new (void);
TaskScanner* task_scanner_new (void);
GType task_get_type (void);
GType command_get_type (void);
GType auto_pipeline_get_type (void);
Command* command_dup (const Command* self);
void command_free (Command* self);
void command_copy (const Command* self, Command* dest);
void command_destroy (Command* self);
Task* task_new (double seconds, Command* command);
Task* task_construct (GType object_type, double seconds, Command* command);
static void _g_list_free_g_object_unref (GList* self);
GList* task_scanner_get_tasks_from_args (TaskScanner* self, char** args, int args_length1);



TaskScanner* task_scanner_new (void) {
	TaskScanner* self;
	self = (TaskScanner*) g_scanner_new (NULL);
	(*((GScanner*) self)->config).scan_identifier_1char = FALSE;
	(*((GScanner*) self)->config).int_2_float = TRUE;
	scanner_register_symbols ((GScanner*) self, (guint) 0);
	return self;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, -1);
	return result;
}


static gpointer _command_dup0 (gpointer self) {
	return self ? command_dup (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


GList* task_scanner_get_tasks_from_args (TaskScanner* self, char** args, int args_length1) {
	GList* result = NULL;
	double last_time_seconds;
	GList* tasks;
	g_return_val_if_fail (self != NULL, NULL);
	last_time_seconds = (double) 0;
	tasks = NULL;
	{
		char** arg_collection;
		int arg_collection_length1;
		int arg_it;
		arg_collection = args;
		arg_collection_length1 = args_length1;
		for (arg_it = 0; arg_it < args_length1; arg_it = arg_it + 1) {
			char* arg;
			arg = g_strdup (arg_collection[arg_it]);
			{
				gint relative;
				GTokenType tok_type;
				double seconds;
				Command* command;
				Task* task;
				if (g_str_has_prefix (arg, "--")) {
					_g_free0 (arg);
					continue;
				}
				g_scanner_input_text ((GScanner*) self, arg, (guint) string_get_length (arg));
				relative = 0;
				tok_type = g_scanner_peek_next_token ((GScanner*) self);
				if (tok_type == G_TOKEN_EOF) {
					_g_free0 (arg);
					break;
				}
				if (tok_type == '+') {
					relative = 1;
				} else {
					if (tok_type == '-') {
						relative = -1;
					}
				}
				if (relative != 0) {
					g_scanner_get_next_token ((GScanner*) self);
				}
				if (g_scanner_peek_next_token ((GScanner*) self) != G_TOKEN_FLOAT) {
					_g_free0 (arg);
					continue;
				}
				g_scanner_get_next_token ((GScanner*) self);
				seconds = ((GScanner*) self)->value.v_float;
				if (relative != 0) {
					seconds = last_time_seconds + (relative * seconds);
				}
				if (g_scanner_peek_next_token ((GScanner*) self) != ':') {
					_g_free0 (arg);
					continue;
				}
				g_scanner_get_next_token ((GScanner*) self);
				if (g_scanner_peek_next_token ((GScanner*) self) != G_TOKEN_SYMBOL) {
					_g_free0 (arg);
					continue;
				}
				g_scanner_get_next_token ((GScanner*) self);
				command = _command_dup0 ((Command*) ((GScanner*) self)->value.v_symbol);
				task = task_new (seconds, command);
				tasks = g_list_append (tasks, _g_object_ref0 (task));
				last_time_seconds = seconds;
				_g_free0 (arg);
				_command_free0 (command);
				_g_object_unref0 (task);
			}
		}
	}
	result = tasks;
	return result;
}




