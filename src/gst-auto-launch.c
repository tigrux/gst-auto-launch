/* gst-auto-launch.c generated by valac, the Vala compiler
 * generated from gst-auto-launch.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>
#include <gst/gst.h>


#define TYPE_AUTO_PIPELINE (auto_pipeline_get_type ())
#define AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AUTO_PIPELINE, AutoPipeline))
#define AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AUTO_PIPELINE, AutoPipelineClass))
#define IS_AUTO_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AUTO_PIPELINE))
#define IS_AUTO_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AUTO_PIPELINE))
#define AUTO_PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AUTO_PIPELINE, AutoPipelineClass))

typedef struct _AutoPipeline AutoPipeline;
typedef struct _AutoPipelineClass AutoPipelineClass;

#define TYPE_OBJECT_LIST (object_list_get_type ())
#define OBJECT_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OBJECT_LIST, ObjectList))
#define OBJECT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OBJECT_LIST, ObjectListClass))
#define IS_OBJECT_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OBJECT_LIST))
#define IS_OBJECT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OBJECT_LIST))
#define OBJECT_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OBJECT_LIST, ObjectListClass))

typedef struct _ObjectList ObjectList;
typedef struct _ObjectListClass ObjectListClass;

#define TYPE_COMMAND (command_get_type ())
typedef struct _Command Command;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_CONFIG_PARSER (config_parser_get_type ())
#define CONFIG_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG_PARSER, ConfigParser))
#define CONFIG_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG_PARSER, ConfigParserClass))
#define IS_CONFIG_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG_PARSER))
#define IS_CONFIG_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG_PARSER))
#define CONFIG_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG_PARSER, ConfigParserClass))

typedef struct _ConfigParser ConfigParser;
typedef struct _ConfigParserClass ConfigParserClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

typedef void (*command_func) (AutoPipeline* ctx, ObjectList* param, void* user_data);
struct _Command {
	char* name;
	char* description;
	command_func function;
	gpointer function_target;
	GDestroyNotify function_target_destroy_notify;
};



GType auto_pipeline_get_type (void);
GType object_list_get_type (void);
void command_play (AutoPipeline* ctx, ObjectList* param);
static void _command_play_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_paused (AutoPipeline* ctx, ObjectList* param);
static void _command_paused_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_ready (AutoPipeline* ctx, ObjectList* param);
static void _command_ready_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_null (AutoPipeline* ctx, ObjectList* param);
static void _command_null_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_wait (AutoPipeline* ctx, ObjectList* param);
static void _command_wait_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_eos (AutoPipeline* ctx, ObjectList* param);
static void _command_eos_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
void command_quit (AutoPipeline* ctx, ObjectList* param);
static void _command_quit_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self);
GType command_get_type (void);
Command* command_dup (const Command* self);
void command_free (Command* self);
void command_copy (const Command* self, Command* dest);
void command_destroy (Command* self);
ConfigParser* config_parser_new (void);
ConfigParser* config_parser_construct (GType object_type);
GType config_parser_get_type (void);
gboolean config_parser_parse_file (ConfigParser* self, const char* filename, GError** error);
char* config_parser_get (ConfigParser* self, const char* key);
AutoPipeline* auto_pipeline_new (void);
AutoPipeline* auto_pipeline_construct (GType object_type);
void auto_pipeline_parse (AutoPipeline* self, const char* description, GError** error);
void auto_pipeline_parse_parameters (AutoPipeline* self, char** args, int args_length1);
void auto_pipeline_exec_parameters (AutoPipeline* self);
GMainLoop* auto_pipeline_get_loop (AutoPipeline* self);
gint _main (char** args, int args_length1);

extern const Command COMMANDS[];


static void _command_play_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_play (ctx, param);
}


static void _command_paused_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_paused (ctx, param);
}


static void _command_ready_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_ready (ctx, param);
}


static void _command_null_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_null (ctx, param);
}


static void _command_wait_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_wait (ctx, param);
}


static void _command_eos_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_eos (ctx, param);
}


static void _command_quit_command_func (AutoPipeline* ctx, ObjectList* param, gpointer self) {
	command_quit (ctx, param);
}


gint _main (char** args, int args_length1) {
	gint result;
	GError * _inner_error_;
	char* pipelines_config;
	ConfigParser* parser;
	gboolean parsed;
	char* pipeline_id;
	char* description;
	AutoPipeline* pipeline;
	char** _tmp3_ = NULL;
	gint _tmp2_;
	_inner_error_ = NULL;
	if (args_length1 < 4) {
		guint i;
		g_print ("Usage: %s <pipelines.xml> <pipeline_id> <commands>\n", args[0]);
		g_print ("Supported commands are:\n");
		i = (guint) 0;
		while (TRUE) {
			Command _tmp0_ = {0};
			Command command;
			command = (command_copy (&COMMANDS[i], &_tmp0_), _tmp0_);
			if (command.name == NULL) {
				command_destroy (&command);
				break;
			}
			g_print ("  -%s:\n    %s\n", command.name, command.description);
			i++;
			command_destroy (&command);
		}
		result = 1;
		return result;
	}
	pipelines_config = g_strdup (args[1]);
	if (!g_file_test (pipelines_config, G_FILE_TEST_IS_REGULAR)) {
		g_print ("'%s' is not a regular file\n", pipelines_config);
		result = 1;
		_g_free0 (pipelines_config);
		return result;
	}
	parser = config_parser_new ();
	parsed = FALSE;
	{
		gboolean _tmp1_;
		_tmp1_ = config_parser_parse_file (parser, pipelines_config, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		parsed = _tmp1_;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_print ("Error: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_free0 (pipelines_config);
		_g_object_unref0 (parser);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (!parsed) {
		g_print ("Could not parse file '%s'\n", pipelines_config);
		result = 1;
		_g_free0 (pipelines_config);
		_g_object_unref0 (parser);
		return result;
	}
	pipeline_id = g_strdup (args[2]);
	description = config_parser_get (parser, pipeline_id);
	if (description == NULL) {
		g_print ("No pipeline found for id '%s'\n", pipeline_id);
		result = 1;
		_g_free0 (pipelines_config);
		_g_object_unref0 (parser);
		_g_free0 (pipeline_id);
		_g_free0 (description);
		return result;
	}
	pipeline = auto_pipeline_new ();
	gst_init (&args_length1, &args);
	{
		auto_pipeline_parse (pipeline, description, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_print ("Error: %s\n", e->message);
			result = 1;
			_g_error_free0 (e);
			_g_free0 (pipelines_config);
			_g_object_unref0 (parser);
			_g_free0 (pipeline_id);
			_g_free0 (description);
			_g_object_unref0 (pipeline);
			return result;
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_free0 (pipelines_config);
		_g_object_unref0 (parser);
		_g_free0 (pipeline_id);
		_g_free0 (description);
		_g_object_unref0 (pipeline);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	auto_pipeline_parse_parameters (pipeline, (_tmp3_ = args + 3, _tmp2_ = args_length1 - 3, _tmp3_), _tmp2_);
	auto_pipeline_exec_parameters (pipeline);
	g_main_loop_run (auto_pipeline_get_loop (pipeline));
	result = 0;
	_g_free0 (pipelines_config);
	_g_object_unref0 (parser);
	_g_free0 (pipeline_id);
	_g_free0 (description);
	_g_object_unref0 (pipeline);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _main (argv, argc);
}




